import { GoogleGenAI, Type } from '@google/genai';
import { AnalysisResult } from '../types';

// SECURITY: Frontend no longer uses API keys directly
// API calls should go through the backend API endpoint
// This is kept for legacy compatibility but should be migrated to backend API calls

const API_KEY = (window as { GEMINI_API_KEY?: string }).GEMINI_API_KEY;

// Gracefully handle missing API key - don't throw, let the backend handle it
// TODO: Migrate to backend API endpoint for secure API key handling
if (!API_KEY) {
  console.warn(
    'GEMINI_API_KEY not found. Frontend should use backend API endpoint instead.'
  );
  // Don't throw - let the backend handle API calls
}

// Only initialize if API_KEY is available (for backward compatibility)
const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;

const analysisSchema = {
  type: Type.OBJECT,
  properties: {
    summary: {
      type: Type.STRING,
      description:
        'A comprehensive summary of the document, generated by the Summarizer Agent.',
    },
    visualization: {
      type: Type.OBJECT,
      description:
        'Data for an interactive visualization, created by the Visualizer Agent.',
      properties: {
        type: {
          type: Type.STRING,
          enum: ['MIND_MAP', 'DEPENDENCY_GRAPH'],
          description:
            "The type of visualization. Use 'MIND_MAP' for documents and 'DEPENDENCY_GRAPH' for codebases.",
        },
        title: {
          type: Type.STRING,
          description: 'A title for the visualization.',
        },
        nodes: {
          type: Type.ARRAY,
          description: 'An array of nodes for the graph.',
          items: {
            type: Type.OBJECT,
            properties: {
              id: {
                type: Type.STRING,
                description:
                  "A unique identifier for the node (e.g., 'concept_1', 'function_A').",
              },
              label: {
                type: Type.STRING,
                description: 'The display name of the node.',
              },
              group: {
                type: Type.STRING,
                description:
                  "An optional group for styling (e.g., 'Core Concept', 'Function', 'Class').",
              },
            },
            required: ['id', 'label'],
          },
        },
        edges: {
          type: Type.ARRAY,
          description: 'An array of edges connecting the nodes.',
          items: {
            type: Type.OBJECT,
            properties: {
              from: {
                type: Type.STRING,
                description: 'The ID of the source node.',
              },
              to: {
                type: Type.STRING,
                description: 'The ID of the target node.',
              },
              label: {
                type: Type.STRING,
                description: 'An optional label describing the relationship.',
              },
            },
            required: ['from', 'to'],
          },
        },
      },
      required: ['type', 'title', 'nodes', 'edges'],
    },
  },
  required: ['summary', 'visualization'],
};

export const runAgenticNavigator = async (
  documentText: string
): Promise<AnalysisResult> => {
  const prompt = `
You are the orchestrator for 'Agentic Navigator', a multi-agent AI system designed to analyze complex documents and codebases. Your team consists of:
1.  **Summarizer Agent**: Creates concise, comprehensive summaries.
2.  **Linker/Visualizer Agent**: Identifies entities and their relationships and structures them for visualization.

Your task is to analyze the provided content and produce a collaborative report.
First, determine if the content is a general document (e.g., article, paper) or a codebase (e.g., script, program).
- If it is a document, create a **MIND_MAP**. Nodes should be key concepts, and edges should represent their relationships.
- If it is a codebase, create a **DEPENDENCY_GRAPH**. Nodes should be functions, classes, modules, or variables, and edges should represent calls, imports, or inheritance.

You MUST respond with a single, valid JSON object that adheres to the defined schema. Ensure all 'from' and 'to' fields in edges correspond to valid node 'id's. Do not include any markdown formatting like \`\`\`json.

Here is the content to analyze:
---
${documentText}
---
`;

  // TODO: Migrate to backend API endpoint (http://localhost:8080/api/analyze)
  // For now, check if API key is available for backward compatibility
  if (!ai) {
    throw new Error(
      'API key not configured. Please use the backend API endpoint instead: http://localhost:8080/api/analyze'
    );
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-pro',
      contents: prompt,
      config: {
        responseMimeType: 'application/json',
        responseSchema: analysisSchema,
      },
    });

    const jsonText = response.text.trim();
    // In case the model still wraps the output in markdown
    const cleanedJsonText = jsonText.replace(/^```json\s*|```$/g, '');
    return JSON.parse(cleanedJsonText) as AnalysisResult;
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    if (error instanceof SyntaxError) {
      console.error('Failed to parse JSON response from API.');
    }
    throw new Error(
      'Failed to get analysis from Agentic Navigator. Please check the console for details.'
    );
  }
};
